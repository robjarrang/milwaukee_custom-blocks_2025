<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Stats Block</title>
    <link rel="stylesheet" href="https://cloud.mail.milwaukeetool.eu/customblock-styles">
    <style>
        body{margin:0;padding:10px;font-family:Arial,sans-serif;background-color:white}.container{max-width:800px;margin:0 auto;background:white;padding:20px;border-radius:8px;;transition:opacity 0.3s ease}.container.loading{opacity:0.6;pointer-events:none}.field-group{margin-bottom:15px}.field-label{display:block;margin-bottom:5px;font-weight:bold;color:#333;font-size:14px}.field-input{width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:4px;font-size:14px;box-sizing:border-box;transition:border-color 0.3s ease}.field-input:focus{outline:none;border-color:#0074d9;box-shadow:0 0 0 2px rgba(0,116,217,0.2)}.field-input.error{border-color:#dc3545;background-color:#fff5f5;box-shadow:0 0 0 2px rgba(220,53,69,0.2)}.field-error{color:#dc3545;font-size:12px;margin-top:4px;display:none;font-weight:500}.field-error.show{display:block}.field-input-wrapper{position:relative}.field-input-wrapper .validation-icon{position:absolute;right:10px;top:50%;transform:translateY(-50%);font-size:16px;pointer-events:none;opacity:0;transition:opacity 0.3s ease}.field-input.error + .validation-icon.error{opacity:1;color:#dc3545}.field-input{transition:all 0.3s ease}.field-input.error{animation:shake 0.5s ease-in-out}@keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}.color-selector{display:flex;gap:10px}.color-option{flex:1;padding:8px;text-align:center;border:2px solid #ddd;border-radius:4px;cursor:pointer;transition:all .2s ease}.color-option:hover{border-color:#0074d9;background-color:#f0f8ff}.color-option.selected{border-color:#0074d9;background-color:#0074d9;color:white}.section-divider{margin:30px 0;border-top:2px solid #eee;padding-top:20px}.section-title{font-size:16px;font-weight:bold;color:#333;margin-bottom:15px}.stats-container{display:flex;flex-direction:column;gap:15px}.stat-item{background-color:#fafafa;padding:20px;border:1px solid #ddd;border-radius:6px;position:relative}.stat-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.stat-title{font-weight:bold;font-size:16px}.stat-controls{display:flex;gap:8px}.stat-control-btn{background:none;border:none;cursor:pointer;padding:5px;font-size:18px;line-height:1;color:#555;transition:color .2s}.stat-control-btn:hover{color:#0074d9}.stat-control-btn:disabled{color:#ccc;cursor:not-allowed}.btn{display:inline-block;padding:10px 15px;background-color:#0074d9;color:white;text-decoration:none;border-radius:4px;border:none;cursor:pointer;font-size:14px;font-weight:bold;transition:background-color .2s}.btn:hover{background-color:#005a9e}.add-stat-btn{margin-top:20px}.loading-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(255,255,255,0.9);display:none;align-items:center;justify-content:center;z-index:9999}.loading-overlay.show{display:flex}.loading-spinner{border:3px solid #f3f3f3;border-top:3px solid #0074d9;border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.error-banner{background-color:#fee;border:1px solid #fcc;color:#c00;padding:10px;margin-bottom:20px;border-radius:4px;display:none}.error-banner.show{display:block}
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay"><div class="loading-spinner"></div></div>

    <div class="container" id="mainContainer">
        <h2 style="margin-top: 0; color: #333;">Stats Block Settings</h2>

        <div class="section-divider" style="margin-top:0; padding-top:0; border-top:none;">
            <div class="section-title">General Settings</div>
            <div class="field-group">
                <label class="field-label">Background Colour</label>
                <div class="color-selector" id="backgroundColorSelector">
                    <div class="color-option" data-color="red">Red</div>
                    <div class="color-option" data-color="black">Black</div>
                </div>
            </div>
        </div>

        <div class="section-divider">
            <div class="section-title">Left Column Image</div>
            <div class="field-group">
                <label class="field-label">Image URL (300px wide)</label>
                <div class="field-input-wrapper">
                    <input type="url" class="field-input" id="imageUrl" placeholder="https://example.com/image.jpg" aria-describedby="imageUrl-error">
                    <span class="validation-icon error">✗</span>
                </div>
                <div class="field-error" id="imageUrl-error" role="alert"></div>
            </div>
            <div class="field-group">
                <label class="field-label">Image Link URL</label>
                <div class="field-input-wrapper">
                    <input type="url" class="field-input" id="imageLink" placeholder="https://example.com/link" aria-describedby="imageLink-error">
                    <span class="validation-icon error">✗</span>
                </div>
                <div class="field-error" id="imageLink-error" role="alert"></div>
            </div>
            <div class="field-group">
                <label class="field-label">Image Alt Text</label>
                <div class="field-input-wrapper">
                    <input type="text" class="field-input" id="imageAlt" placeholder="Descriptive text" maxlength="100" aria-describedby="imageAlt-error">
                    <span class="validation-icon error">✗</span>
                </div>
                <div class="field-error" id="imageAlt-error" role="alert"></div>
            </div>
        </div>

        <div class="section-divider">
            <div class="section-title">Right Column Stats</div>
            <div id="statsContainer" class="stats-container"></div>
            <button id="addStatBtn" class="btn add-stat-btn">Add Stat</button>
        </div>
    </div>

    <template id="statTemplate">
        <div class="stat-item">
            <div class="stat-header">
                <h3 class="stat-title">Stat</h3>
                <div class="stat-controls">
                    <button class="stat-control-btn move-up-btn" title="Move Up">▲</button>
                    <button class="stat-control-btn move-down-btn" title="Move Down">▼</button>
                    <button class="stat-control-btn remove-btn" title="Remove Stat">×</button>
                </div>
            </div>
            <div class="field-group">
                <label class="field-label">Value</label>
                <div class="field-input-wrapper">
                    <input type="text" class="field-input" data-field="value" placeholder="800+" maxlength="20" required aria-describedby="value-error">
                    <span class="validation-icon error">✗</span>
                </div>
                <div class="field-error" id="value-error" role="alert"></div>
            </div>
            <div class="field-group">
                <label class="field-label">Label</label>
                <div class="field-input-wrapper">
                    <input type="text" class="field-input" data-field="label" placeholder="NEW INNOVATIONS" maxlength="50" required aria-describedby="label-error">
                    <span class="validation-icon error">✗</span>
                </div>
                <div class="field-error" id="label-error" role="alert"></div>
            </div>
        </div>
    </template>

    <script src="https://cloud.mail.milwaukeetool.eu/customblock-base"></script>
    <script src="https://cloud.mail.milwaukeetool.eu/customblock-blocksdk"></script>
    <script>
        'use strict';

        // --- Config and State ---
        const PRESET_COLORS = { RED: '#DB021D', BLACK: '#000000' };
        const DEFAULTS = { backgroundColor: 'red', statItems: [{ id: crypto.randomUUID(), number: '87', label: 'Projects completed', alignment: 'center' }] };
        const state = { sdk: null, dom: null };
        const elements = {};
        
        // Create a DOM cache utility to consolidate repeated DOM queries
        const DOMCache = {
            cache: new Map(),
            
            get(selector) {
                if (!this.cache.has(selector)) {
                    this.cache.set(selector, document.querySelector(selector));
                }
                return this.cache.get(selector);
            },
            
            getAll(selector) {
                if (!this.cache.has(selector + '_all')) {
                    this.cache.set(selector + '_all', document.querySelectorAll(selector));
                }
                return this.cache.get(selector + '_all');
            },
            
            clear() {
                this.cache.clear();
            }
        };

        // Utility for retryable operations
        const RetryableOperation = {
            async execute(operation, options = {}) {
                const {
                    maxRetries = 3,
                    delay = 1000,
                    backoff = 2,
                    onRetry = () => {}
                } = options;
                
                let lastError;
                
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        return await operation();
                    } catch (error) {
                        lastError = error;
                        if (i < maxRetries - 1) {
                            onRetry(i + 1, error);
                            await new Promise(resolve => 
                                setTimeout(resolve, delay * Math.pow(backoff, i))
                            );
                        }
                    }
                }
                
                throw lastError;
            }
        };

        // Enhanced validation utility
        const Validator = {
            rules: {
                url: (value) => !value || utils.isValidUrl(value),
                email: (value) => !value || /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
                number: (min, max) => (value) => {
                    const num = parseFloat(value);
                    return !isNaN(num) && num >= min && num <= max;
                },
                length: (max) => (value) => !value || value.length <= max,
                required: (value) => value && value.trim().length > 0,
                alphanumeric: (value) => !value || /^[a-zA-Z0-9\s]+$/.test(value),
                noHtml: (value) => !value || !/[<>]/.test(value)
            },
            
            validateField(input, rules, errorElement = null) {
                const isValid = rules.every(rule => rule(input.value));
                
                // Visual feedback
                input.classList.toggle('error', !isValid);
                input.setAttribute('aria-invalid', !isValid);
                
                // Show/hide error message if error element provided
                if (errorElement) {
                    errorElement.classList.toggle('show', !isValid);
                    if (!isValid) {
                        errorElement.textContent = this.getErrorMessage(input, rules);
                    }
                }
                
                // Add visual success indicator for valid non-empty inputs
                if (isValid && input.value.trim()) {
                    input.classList.add('valid');
                } else {
                    input.classList.remove('valid');
                }
                
                return isValid;
            },
            
            getErrorMessage(input, rules) {
                const value = input.value;
                
                if (rules.includes(this.rules.required) && !value.trim()) {
                    return 'This field is required';
                }
                if (rules.includes(this.rules.url) && !this.rules.url(value)) {
                    return 'Please enter a valid URL (http:// or https://)';
                }
                if (rules.includes(this.rules.email) && !this.rules.email(value)) {
                    return 'Please enter a valid email address';
                }
                if (rules.some(rule => rule.toString().includes('length')) && value.length > 0) {
                    const maxLength = input.getAttribute('maxlength') || '100';
                    return `Maximum ${maxLength} characters allowed`;
                }
                if (rules.includes(this.rules.noHtml) && !this.rules.noHtml(value)) {
                    return 'HTML tags are not allowed';
                }
                
                return 'Invalid input';
            },
            
            // Real-time validation setup
            setupRealTimeValidation(input, rules, errorElement = null) {
                const validateInput = () => {
                    return this.validateField(input, rules, errorElement);
                };
                
                input.addEventListener('input', validateInput);
                input.addEventListener('blur', validateInput);
                
                if (input.value) {
                    validateInput();
                }
                
                return validateInput;
            },
            
            // Validate all form fields
            validateAll(container = document) {
                const inputs = container.querySelectorAll('.field-input');
                let allValid = true;
                
                inputs.forEach(input => {
                    const rules = [];
                    
                    // Add rules based on input attributes and type
                    if (input.hasAttribute('required') || input.dataset.field === 'value' || input.dataset.field === 'label') {
                        rules.push(this.rules.required);
                    }
                    if (input.type === 'url') {
                        rules.push(this.rules.url);
                    }
                    if (input.type === 'email') {
                        rules.push(this.rules.email);
                    }
                    if (input.hasAttribute('maxlength')) {
                        const max = parseInt(input.getAttribute('maxlength'));
                        rules.push(this.rules.length(max));
                    }
                    
                    rules.push(this.rules.noHtml);
                    
                    const errorElement = input.closest('.field-group')?.querySelector('.field-error');
                    const isValid = this.validateField(input, rules, errorElement);
                    
                    if (!isValid) {
                        allValid = false;
                    }
                });
                
                return allValid;
            }
        };
        
        const utils = {
            debounce: (func, wait) => { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => func.apply(this, a), wait); }; },
            
            isValidUrl(s) { if (!s || s.trim() === '') return true; try { new URL(s); return true; } catch (e) { return false; } },
            
            // SDK operations with retry logic
            async performSDKOperation(operation, operationName = 'SDK operation', options = {}) {
                return RetryableOperation.execute(
                    operation,
                    {
                        maxRetries: 2,
                        delay: 500,
                        onRetry: (attempt, error) => {
                            console.log(`Retrying ${operationName}... Attempt ${attempt}:`, error.message);
                        },
                        ...options
                    }
                );
            },
            
            getValue: (key) => state.dom[key] !== undefined ? state.dom[key] : DEFAULTS[key]
        };        // --- DOM and Template Generation ---
        function parseToDOM(html) {
            const doc = new DOMParser().parseFromString(html, 'text/html');
            return doc.body.firstChild;
        }

        function createStatRowTemplate(stat = { value: '', label: '' }) {
            const spacerRow = '<tr><td><div style="font-size: 20px; height: 20px; line-height: 20px;"> </div></td></tr>';
            const statRow = `
                <tr><td class="mobile-text-center" style="text-align: center;">
                    <div style="color: #ffffff; font-family: 'Helvetica Neue LT W05_93 Blk E', Arial, sans-serif, 'Open-Sans'; font-size: 44px; font-weight: bold; line-height: 48px; margin: 0; text-transform: uppercase;">${stat.value}</div>
                    <div style="font-size: 16px; line-height: 22px; font-weight: normal; color: #ffffff; font-family: 'Helvetica Neue LT W05_55 Roman', sans-serif, 'Open-Sans';">${stat.label}</div>
                </td></tr>`;
            // We return a DocumentFragment to hold both rows if needed
            const tpl = document.createElement('template');
            tpl.innerHTML = statRow + spacerRow;
            return tpl.content;
        }

        function generateInitialTemplate(d) {
            const statsHtml = d.stats.map((stat, index) => {
                const isLast = index === d.stats.length - 1;
                return `
                <tr><td class="mobile-text-center" style="text-align: center;">
                    <div style="color: #ffffff; font-family: 'Helvetica Neue LT W05_93 Blk E', Arial, sans-serif, 'Open-Sans'; font-size: 44px; font-weight: bold; line-height: 48px; margin: 0; text-transform: uppercase;">${stat.value}</div>
                    <div style="font-size: 16px; line-height: 22px; font-weight: normal; color: #ffffff; font-family: 'Helvetica Neue LT W05_55 Roman', sans-serif, 'Open-Sans';">${stat.label}</div>
                </td></tr>
                ${!isLast ? '<tr><td><div style="font-size: 20px; height: 20px; line-height: 20px;"> </div></td></tr>' : ''}`;
            }).join('');

            return `<!-- START .stats-image-block --><table align="center" border="0" cellpadding="0" cellspacing="0" class="content-outer" role="presentation" style="background-color: ${d.backgroundColor}; width: 620px;"><tr><td class="side" style="width: 20px;"> </td><td align="center" class="content-inner" style="width: 580px;" valign="middle"><table align="center" border="0" cellpadding="0" cellspacing="0" class="sect" role="presentation" style="width: 100%;"><tr><td class="block" style="width: 290px;" valign="middle"><table align="center" border="0" cellpadding="0" cellspacing="0" class="sect" role="presentation" style="width: 100%;"><tr><td><a href="${d.imageLink}" target="_blank"><img align="top" alt="${d.imageAlt}" class="fill" src="${d.imageUrl}" style="border: none; display: block; height: auto; outline: none; text-decoration: none;" width="300"></a></td></tr></table></td><td class="block" style="width: 290px;" valign="middle"><table border="0" cellpadding="0" cellspacing="0" class="sect" style="width: 100%;"><tr><td><div style="font-size: 16px; height: 16px; line-height: 16px;"> </div></td></tr>${statsHtml}<tr><td><div style="font-size: 16px; height: 16px; line-height: 16px;"> </div></td></tr></table></td></tr></table></td><td class="side" style="width: 20px;"> </td></tr></table><!-- END .stats-image-block -->`;
        }

        // --- UI Sync and Rendering ---
        let rafId = null;
        function renderStatsUI() {
            if (!state.dom) return;
            const statsTableBody = state.dom.querySelector('.block:last-child .sect > tbody');
            const statRows = Array.from(statsTableBody.children).filter(tr => tr.querySelector('.mobile-text-center'));
            elements.statsContainer.replaceChildren();

            // Use DocumentFragment for batch DOM operations
            const fragment = document.createDocumentFragment();

            statRows.forEach((row, index) => {
                const value = row.querySelector('div:first-child').textContent.trim();
                const label = row.querySelector('div:last-child').textContent.trim();
                const itemFragment = elements.statTemplate.content.cloneNode(true);
                const itemEl = itemFragment.querySelector('.stat-item');
                itemEl.dataset.index = index;
                itemEl.querySelector('.stat-title').textContent = `Stat ${index + 1}`;
                itemEl.querySelector('[data-field="value"]').value = value;
                itemEl.querySelector('[data-field="label"]').value = label;
                itemEl.querySelector('.move-up-btn').disabled = (index === 0);
                itemEl.querySelector('.move-down-btn').disabled = (index === statRows.length - 1);
                fragment.appendChild(itemFragment);
            });

            // Single DOM update with all stats
            elements.statsContainer.appendChild(fragment);
        }

        function updateUIFromDOM() {
            if (!state.dom) return;
            const link = state.dom.querySelector('a');
            const img = state.dom.querySelector('img');

            // General settings
            const domColor = state.dom.style.backgroundColor;
            const redRgb = 'rgb(219, 2, 29)';
            const blackRgb = 'rgb(0, 0, 0)';
            elements.backgroundColorSelector.querySelector('[data-color="red"]').classList.toggle('selected', domColor === PRESET_COLORS.RED.toLowerCase() || domColor === redRgb);
            elements.backgroundColorSelector.querySelector('[data-color="black"]').classList.toggle('selected', domColor === PRESET_COLORS.BLACK || domColor === blackRgb);

            // Image settings
            elements.imageUrl.value = img ? img.src : '';
            elements.imageLink.value = link ? link.href : '';
            elements.imageAlt.value = img ? img.alt : '';

            // Stats list
            renderStatsUI();
        }

        // --- SDK Interaction ---
        function updateBlock() {
            if (!state.dom) return;
            state.sdk.setContent(state.dom.outerHTML);
        }
        const debouncedUpdateBlock = utils.debounce(() => {
            if (rafId) cancelAnimationFrame(rafId);

            rafId = requestAnimationFrame(() => {
                updateBlock();
            });
        }, 500);

        // --- Initialization and Event Handlers ---
        function cacheElements() {
            for (const id of ['mainContainer', 'loadingOverlay', 'backgroundColorSelector', 'imageUrl', 'imageLink', 'imageAlt', 'statsContainer', 'addStatBtn', 'statTemplate']) {
                elements[id] = document.getElementById(id);
            }
        }

        function initializeEventHandlers() {
            // General Settings
            elements.backgroundColorSelector.addEventListener('click', e => {
                const button = e.target.closest('.color-option');
                if (button && state.dom) {
                    state.dom.style.backgroundColor = (button.dataset.color === 'red') ? PRESET_COLORS.RED : PRESET_COLORS.BLACK;
                    updateUIFromDOM();
                    updateBlock();
                }
            });

            // Image Settings
            elements.imageUrl.addEventListener('input', () => { if (state.dom) state.dom.querySelector('img').src = elements.imageUrl.value; debouncedUpdateBlock(); });
            elements.imageLink.addEventListener('input', () => { if (state.dom) state.dom.querySelector('a').href = elements.imageLink.value; debouncedUpdateBlock(); });
            elements.imageAlt.addEventListener('input', () => { if (state.dom) state.dom.querySelector('img').alt = elements.imageAlt.value; debouncedUpdateBlock(); });

            // Add Stat Button
            elements.addStatBtn.addEventListener('click', () => {
                if (!state.dom) return;
                const statsTableBody = state.dom.querySelector('.block:last-child .sect > tbody');
                const lastStatRow = Array.from(statsTableBody.children).filter(tr => tr.querySelector('.mobile-text-center')).pop();
                const newStatFragment = createStatRowTemplate({ value: '123', label: 'NEW' });
                if (lastStatRow) {
                    lastStatRow.after(...newStatFragment.children); // Use spread to insert both rows
                } else {
                    statsTableBody.append(...newStatFragment.children);
                }
                updateUIFromDOM();
                updateBlock();
            });

            // Optimized Event Delegation with Action Maps
            const statActions = {
                '.remove-btn': (itemEl, index) => {
                    const statsTableBody = state.dom.querySelector('.block:last-child .sect > tbody');
                    const allRows = Array.from(statsTableBody.children);
                    const statRows = allRows.filter(tr => tr.querySelector('.mobile-text-center'));
                    const targetRow = statRows[index];
                    const targetRowIndex = allRows.indexOf(targetRow);
                    const spacerRow = allRows[targetRowIndex + 1];

                    targetRow.remove();
                    if (spacerRow && spacerRow.textContent.trim() === '') spacerRow.remove();
                    return true;
                },
                '.move-up-btn': (itemEl, index) => {
                    if (index === 0) return false;

                    const statsTableBody = state.dom.querySelector('.block:last-child .sect > tbody');
                    const allRows = Array.from(statsTableBody.children);
                    const statRows = allRows.filter(tr => tr.querySelector('.mobile-text-center'));
                    const targetRow = statRows[index];
                    const targetRowIndex = allRows.indexOf(targetRow);
                    const spacerRow = allRows[targetRowIndex + 1];
                    const prevRow = statRows[index - 1];

                    prevRow.before(targetRow);
                    targetRow.after(spacerRow);
                    return true;
                },
                '.move-down-btn': (itemEl, index) => {
                    const statsTableBody = state.dom.querySelector('.block:last-child .sect > tbody');
                    const allRows = Array.from(statsTableBody.children);
                    const statRows = allRows.filter(tr => tr.querySelector('.mobile-text-center'));

                    if (index >= statRows.length - 1) return false;

                    const targetRow = statRows[index];
                    const targetRowIndex = allRows.indexOf(targetRow);
                    const spacerRow = allRows[targetRowIndex + 1];
                    const nextRow = statRows[index + 1];
                    const nextSpacer = allRows[allRows.indexOf(nextRow) + 1];

                    if (nextSpacer) {
                        nextSpacer.after(targetRow);
                        targetRow.after(spacerRow);
                    }
                    return true;
                }
            };

            function createStatDelegatedHandler(actionMap) {
                return (event) => {
                    const btn = event.target.closest('.stat-control-btn');
                    if (!btn || !state.dom) return;

                    const itemEl = btn.closest('.stat-item');
                    const index = parseInt(itemEl.dataset.index, 10);

                    let actionExecuted = false;

                    // Execute action using action map
                    for (const [selector, action] of Object.entries(actionMap)) {
                        if (btn.matches(selector)) {
                            const result = action(itemEl, index);

                            if (result) {
                                actionExecuted = true;
                                updateUIFromDOM();
                                updateBlock();
                            }
                            break;
                        }
                    }

                    if (!actionExecuted) {
                        console.log('No matching action found for selector');
                    }
                };
            }

            // Handle Stat Item changes (input, move, remove)
            elements.statsContainer.addEventListener('input', e => {
                if (e.target.matches('[data-field]')) {
                    const itemEl = e.target.closest('.stat-item');
                    const index = parseInt(itemEl.dataset.index, 10);
                    const field = e.target.dataset.field; // 'value' or 'label'
                    const statsTableBody = state.dom.querySelector('.block:last-child .sect > tbody');
                    const statRows = Array.from(statsTableBody.children).filter(tr => tr.querySelector('.mobile-text-center'));
                    const targetRow = statRows[index];
                    if(targetRow) {
                        const targetDiv = targetRow.querySelector(field === 'value' ? 'div:first-child' : 'div:last-child');
                        targetDiv.textContent = e.target.value;
                        debouncedUpdateBlock();
                    }
                }
            });

            elements.statsContainer.addEventListener('click', createStatDelegatedHandler(statActions));
        }

        function loadData() {
            state.sdk.getContent(content => {
                if (content && content.trim() !== '') {
                    state.dom = parseToDOM(content);
                } else {
                    state.dom = parseToDOM(generateInitialTemplate(DEFAULTS));
                    updateBlock();
                }
                updateUIFromDOM();
            });
        }

        // Enhanced cleanup function
        function cleanup() {
            // Cancel any pending RAF
            if (rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }

            // Clear DOM cache
            DOMCache.clear();

            console.log('Stats cleanup completed');
        }

        function initialize() {
            cacheElements();
            state.sdk = new window.sfdc.BlockSDK({ 
                tabs: ['htmlblock'] 
            });
            initializeEventHandlers();
            loadData();

            // Add cleanup on page unload
            window.addEventListener('beforeunload', cleanup);

            // Add automatic cleanup on visibility change
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    console.log('Tab hidden - pausing expensive operations');
                    
                    // Pause expensive operations
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                        rafId = null;
                    }
                    
                    // Clear caches to free memory
                    DOMCache.clear();
                    
                    // Run garbage collection hint if available
                    if (window.gc) {
                        console.log('Running garbage collection hint');
                        window.gc();
                    }
                } else {
                    console.log('Tab visible - resuming operations');
                    
                    // Resume operations if needed
                    if (state.sdk && state.dom) {
                        // Recache elements after clearing
                        cacheElements();
                        
                        // Refresh to ensure sync
                        updateUIFromDOM();
                        
                        console.log('Operations resumed');
                    }
                }
            });
        }

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>