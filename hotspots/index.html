<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Interactive Hotspots Block</title>
    <style>
        body{margin:0;padding:0;font-family:Arial,sans-serif;background-color:#ffffff}.container{max-width:800px;margin:0 auto;background:white;padding:20px;transition:opacity 0.3s ease}.container.loading{opacity:0.6;pointer-events:none}.field-group{margin-bottom:15px}.field-label{display:block;margin-bottom:5px;font-weight:bold;color:#333;font-size:14px}.field-input{width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:4px;font-size:14px;box-sizing:border-box;transition:border-color 0.3s ease}.field-input:focus{outline:none;border-color:#0074d9;box-shadow:0 0 0 2px rgba(0,116,217,0.2)}.section-title{font-size:18px;font-weight:bold;color:#333;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid #eee}.items-container{display:flex;flex-direction:column;gap:15px;max-height:400px;overflow-y:auto;padding-right:10px}.item{background-color:#fafafa;padding:15px;border:2px solid #ddd;border-radius:6px;position:relative;cursor:pointer;transition:border-color .2s, background-color .2s}.item.selected{border-color:#0074d9;background-color:#f0f8ff}.item-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.item-title{font-weight:bold;font-size:16px;margin:0}.item-controls{display:flex;gap:8px}.item-control-btn{background:none;border:none;cursor:pointer;padding:5px;font-size:18px;line-height:1;color:#555;transition:color .2s}.item-control-btn:hover{color:#0074d9}.item-control-btn:disabled{color:#ccc;cursor:not-allowed}.btn{display:inline-block;padding:10px 15px;background-color:#0074d9;color:white;text-decoration:none;border-radius:4px;border:none;cursor:pointer;font-size:14px;font-weight:bold;transition:background-color .2s}.btn:hover{background-color:#005a9e}.add-item-btn{margin-top:20px}.loading-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(255,255,255,0.9);display:none;align-items:center;justify-content:center;z-index:9999}.loading-overlay.show{display:flex}.loading-spinner{border:3px solid #f3f3f3;border-top:3px solid #0074d9;border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
        
        /* Enhanced validation styles */
        .field-input.error{border-color:#dc3545;background-color:#fff5f5;box-shadow:0 0 0 2px rgba(220,53,69,0.2)}
        .field-error{color:#dc3545;font-size:12px;margin-top:4px;display:none;font-weight:500}
        .field-error.show{display:block}
        
        /* Validation icons */
        .field-input-wrapper{position:relative}
        .field-input-wrapper .validation-icon{position:absolute;right:10px;top:50%;transform:translateY(-50%);font-size:16px;pointer-events:none;opacity:0;transition:opacity 0.3s ease}
        .field-input.error + .validation-icon.error{opacity:1;color:#dc3545}
        
        /* Real-time feedback animations */
        .field-input{transition:all 0.3s ease}
        .field-input.error{animation:shake 0.5s ease-in-out}
        
        @keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}
        /* Visual Editor Styles */
        #visualEditorWrapper{margin-top:20px}#visualEditor{position:relative;cursor:crosshair;background-color:#f0f0f0;border:1px solid #ccc;min-height:200px}#previewImage{display:block;width:100%;height:auto}#visualEditor .hotspot-marker{position:absolute;width:24px;height:24px;background-image:url('https://image.mail.milwaukeetool.eu/lib/fe2f11717564047a761c78/m/1/ba4b84d2-b601-42a6-a8e3-e2f32eb1100c.png');background-size:cover;transform:translate(-50%, -50%);border-radius:50%;box-shadow:0 0 0 3px rgba(255,0,0,0.7);cursor:pointer}#visualEditor .hotspot-marker.selected{box-shadow:0 0 0 3px rgba(0,116,217,1);z-index:10}
        /* Tooltip Position Selector Styles */
        .position-selector{display:grid;grid-template-columns:repeat(3, 1fr);gap:5px;width:100px;margin-top:5px}.position-button{width:30px;height:30px;border:1px solid #ccc;border-radius:4px;background-color:#fff;cursor:pointer;position:relative;display:flex;align-items:center;justify-content:center}.position-button:hover{background-color:#e9e9e9}.position-button.selected{background-color:#0074d9;border-color:#005a9e}.position-button .dot{width:6px;height:6px;background-color:#333;border-radius:50%}.position-button.selected .dot{background-color:#fff}
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay"><div class="loading-spinner"></div></div>

    <div class="container" id="mainContainer">
        <h2 style="margin-top: 0; color: #333;">Hotspots Module</h2>

        <div class="section-title">Global Settings</div>
        <div class="field-group">
            <label for="backgroundImageUrl" class="field-label">Interactive Background Image URL</label>
            <div class="field-input-wrapper">
                <input type="url" id="backgroundImageUrl" class="field-input" placeholder="https://example.com/image.jpg" aria-describedby="backgroundImageUrl-error">
                <span class="validation-icon error">✗</span>
            </div>
            <div class="field-error" id="backgroundImageUrl-error" role="alert"></div>
        </div>
        <div class="field-group">
            <label for="fallbackImageUrl" class="field-label">Fallback Image URL</label>
            <div class="field-input-wrapper">
                <input type="url" id="fallbackImageUrl" class="field-input" placeholder="https://example.com/fallback.jpg" aria-describedby="fallbackImageUrl-error">
                <span class="validation-icon error">✗</span>
            </div>
            <div class="field-error" id="fallbackImageUrl-error" role="alert"></div>
        </div>
        <div class="field-group">
            <label for="fallbackLinkUrl" class="field-label">Fallback Image Link URL</label>
            <div class="field-input-wrapper">
                <input type="url" id="fallbackLinkUrl" class="field-input" placeholder="https://example.com/link" aria-describedby="fallbackLinkUrl-error">
                <span class="validation-icon error">✗</span>
            </div>
            <div class="field-error" id="fallbackLinkUrl-error" role="alert"></div>
        </div>

        <div class="section-title">Visual Editor</div>
        <p style="font-size:13px; color:#666; margin-top:-10px; margin-bottom:15px;">Select a hotspot from the list below, then click on the image to set its position.</p>
        <div id="visualEditorWrapper"><div id="visualEditor"><img id="previewImage" src="" alt="Image Preview"></div></div>

        <!-- THE FIX: The "Add New Hotspot" button has been moved here -->
        <button id="addItemBtn" class="btn add-item-btn">Add New Hotspot</button>

        <div class="section-title" style="margin-top: 20px;">Hotspots</div>
        <div id="itemsContainer" class="items-container"></div>
    </div>

    <!-- Template for a single hotspot item's UI -->
    <template id="itemTemplate">
        <div class="item">
            <div class="item-header">
                <h3 class="item-title">Hotspot</h3>
                <div class="item-controls">
                    <button class="item-control-btn move-up-btn" title="Move Up">▲</button>
                    <button class="item-control-btn move-down-btn" title="Move Down">▼</button>
                    <button class="item-control-btn remove-btn" title="Remove Item">×</button>
                </div>
            </div>
            <div class="field-group">
                <label class="field-label">Tooltip Text</label>
                <div class="field-input-wrapper">
                    <input type="text" class="field-input" data-field="text" placeholder="Enter tooltip text" maxlength="100" required aria-describedby="text-error">
                    <span class="validation-icon error">✗</span>
                </div>
                <div class="field-error" id="text-error" role="alert"></div>
            </div>
            <div class="field-group" style="margin-bottom:0;"><label class="field-label">Tooltip Position</label>
                <div class="position-selector">
                    <button class="position-button" data-position="top-left"><div class="dot"></div></button>
                    <button class="position-button" data-position="top"><div class="dot"></div></button>
                    <button class="position-button" data-position="top-right"><div class="dot"></div></button>
                    <button class="position-button" data-position="left"><div class="dot"></div></button>
                    <button class="position-button" data-position="center"><div class="dot"></div></button>
                    <button class="position-button" data-position="right"><div class="dot"></div></button>
                    <button class="position-button" data-position="bottom-left"><div class="dot"></div></button>
                    <button class="position-button" data-position="bottom"><div class="dot"></div></button>
                    <button class="position-button" data-position="bottom-right"><div class="dot"></div></button>
                </div>
            </div>
        </div>
    </template>

    <script src="https://cloud.mail.milwaukeetool.eu/customblock-base"></script>
    <script src="https://cloud.mail.milwaukeetool.eu/customblock-blocksdk"></script>
    <script>
        'use strict';

        const moduleConfig = {
            name: 'Hotspots',
            fields: {
                backgroundImageUrl: { type: 'url', defaultValue: 'https://image.s50.sfmc-content.com/lib/fe301171756404787c1679/m/1/723acaf7-6e04-48f7-9bf6-cce69ec81b2f.png' },
                fallbackImageUrl: { type: 'url', defaultValue: 'https://image.s50.sfmc-content.com/lib/fe301171756404787c1679/m/1/723acaf7-6e04-48f7-9bf6-cce69ec81b2f.png' },
                fallbackLinkUrl: { type: 'url', defaultValue: 'https://www.milwaukeetool.eu/' },
                hotspots: {
                    type: 'list',
                    defaultValue: [
                        { text: 'Mechanical Clutch', posX: 35, posY: 18, tooltipPosition: 'right' },
                        { text: 'REDLINK™ Intelligence', posX: 57, posY: 70, tooltipPosition: 'top-left' },
                    ]
                }
            },
            debounceDelay: 400
        };

        const state = { sdk: null, blockData: {}, selectedHotspotId: null };
        const elements = {};

        // Create a DOM cache utility to consolidate repeated DOM queries
        const DOMCache = {
            cache: new Map(),
            get(selector) {
                if (!this.cache.has(selector)) {
                    this.cache.set(selector, document.querySelector(selector));
                }
                return this.cache.get(selector);
            },
            getAll(selector) {
                if (!this.cache.has(selector + '_all')) {
                    this.cache.set(selector + '_all', document.querySelectorAll(selector));
                }
                return this.cache.get(selector + '_all');
            },
            clear() { this.cache.clear(); },
            clearDynamic() {
                const dynamicKeys = Array.from(this.cache.keys()).filter(key => 
                    key.includes('.hotspot') || key.includes('[data-')
                );
                dynamicKeys.forEach(key => this.cache.delete(key));
            }
        };

        // Utility for retryable operations
        const RetryableOperation = {
            async execute(operation, options = {}) {
                const { maxRetries = 3, delay = 1000, backoff = 2, onRetry = () => {} } = options;
                let lastError;
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        return await operation();
                    } catch (error) {
                        lastError = error;
                        if (i < maxRetries - 1) {
                            onRetry(i + 1, error);
                            await new Promise(resolve => setTimeout(resolve, delay * Math.pow(backoff, i)));
                        }
                    }
                }
                throw lastError;
            }
        };

        // Enhanced validation utility
        const Validator = {
            rules: {
                url: (value) => !value || utils.isValidUrl(value),
                email: (value) => !value || /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
                number: (min, max) => (value) => {
                    const num = parseFloat(value);
                    return !isNaN(num) && num >= min && num <= max;
                },
                length: (max) => (value) => !value || value.length <= max,
                required: (value) => value && value.trim().length > 0,
                alphanumeric: (value) => !value || /^[a-zA-Z0-9\s]+$/.test(value),
                noHtml: (value) => !value || !/[<>]/.test(value)
            },
            
            validateField(input, rules, errorElement = null) {
                const isValid = rules.every(rule => rule(input.value));
                
                // Visual feedback
                input.classList.toggle('error', !isValid);
                
                // Add aria-invalid for accessibility
                input.setAttribute('aria-invalid', !isValid);
                
                // Show/hide error message if error element provided
                if (errorElement) {
                    errorElement.style.display = isValid ? 'none' : 'block';
                    if (!isValid) {
                        errorElement.textContent = this.getErrorMessage(input, rules);
                    }
                }
                
                return isValid;
            },
            
            getErrorMessage(input, rules) {
                const value = input.value;
                
                if (rules.includes(this.rules.required) && !value.trim()) {
                    return 'This field is required';
                }
                if (rules.includes(this.rules.url) && !this.rules.url(value)) {
                    return 'Please enter a valid URL (http:// or https://)';
                }
                if (rules.includes(this.rules.email) && !this.rules.email(value)) {
                    return 'Please enter a valid email address';
                }
                if (rules.some(rule => rule.toString().includes('length')) && value.length > 0) {
                    const maxLength = input.getAttribute('maxlength') || '100';
                    return `Maximum ${maxLength} characters allowed`;
                }
                if (rules.includes(this.rules.noHtml) && !this.rules.noHtml(value)) {
                    return 'HTML tags are not allowed';
                }
                
                return 'Invalid input';
            },
            
            // Real-time validation setup
            setupRealTimeValidation(input, rules, errorElement = null) {
                const validateInput = () => {
                    return this.validateField(input, rules, errorElement);
                };
                
                // Validate on input (immediate feedback)
                input.addEventListener('input', validateInput);
                
                // Validate on blur (final check)
                input.addEventListener('blur', validateInput);
                
                // Initial validation if field has value
                if (input.value) {
                    validateInput();
                }
                
                return validateInput;
            },
            
            // Validate all form fields
            validateAll(container = document) {
                const inputs = container.querySelectorAll('.field-input[data-field]');
                let allValid = true;
                
                inputs.forEach(input => {
                    const rules = [];
                    
                    // Add rules based on input attributes and type
                    if (input.hasAttribute('required') || input.dataset.field === 'text') {
                        rules.push(this.rules.required);
                    }
                    if (input.type === 'url') {
                        rules.push(this.rules.url);
                    }
                    if (input.type === 'email') {
                        rules.push(this.rules.email);
                    }
                    if (input.hasAttribute('maxlength')) {
                        const max = parseInt(input.getAttribute('maxlength'));
                        rules.push(this.rules.length(max));
                    }
                    
                    // Always check for HTML
                    rules.push(this.rules.noHtml);
                    
                    const errorElement = input.closest('.field-group')?.querySelector('.field-error');
                    const isValid = this.validateField(input, rules, errorElement);
                    
                    if (!isValid) {
                        allValid = false;
                    }
                });
                
                return allValid;
            }
        };

        let rafId = null;
        const utils = {
            debounce(func, wait) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => func.apply(this, a), wait); }; },
            getFieldValue(f) { return state.blockData[f] !== undefined ? state.blockData[f] : moduleConfig.fields[f].defaultValue; },
            isValidUrl(url) {
                if (!url) return true; // Empty URL is considered valid (optional field)
                try {
                    const urlObj = new URL(url);
                    return urlObj.protocol === 'http:' || urlObj.protocol === 'https:';
                } catch {
                    return false;
                }
            }
        };

        function cacheElements() {
            Object.assign(elements, {
                mainContainer: document.getElementById('mainContainer'),
                loadingOverlay: document.getElementById('loadingOverlay'),
                backgroundImageUrl: document.getElementById('backgroundImageUrl'),
                fallbackImageUrl: document.getElementById('fallbackImageUrl'),
                fallbackLinkUrl: document.getElementById('fallbackLinkUrl'),
                visualEditor: document.getElementById('visualEditor'),
                previewImage: document.getElementById('previewImage'),
                itemsContainer: document.getElementById('itemsContainer'),
                addItemBtn: document.getElementById('addItemBtn'),
                itemTemplate: document.getElementById('itemTemplate')
            });
        }

        function setLoadingState(loading) {
            if (elements.mainContainer) {
                elements.mainContainer.classList.toggle('loading', loading);
                elements.loadingOverlay.classList.toggle('show', loading);
            }
        }

        const updateStateFromUI = utils.debounce(() => {
            // Validate all form fields before updating
            const isFormValid = Validator.validateAll(elements.itemsContainer);
            
            // Validate global fields
            const globalFields = [
                { element: elements.backgroundImageUrl, rules: [Validator.rules.url] },
                { element: elements.fallbackImageUrl, rules: [Validator.rules.url] },
                { element: elements.fallbackLinkUrl, rules: [Validator.rules.url] }
            ];
            
            let globalValid = true;
            globalFields.forEach(({ element, rules }) => {
                const errorElement = element.closest('.field-group')?.querySelector('.field-error');
                if (!Validator.validateField(element, rules, errorElement)) {
                    globalValid = false;
                }
            });
            
            // Only update if valid
            if (isFormValid && globalValid) {
                state.blockData.backgroundImageUrl = elements.backgroundImageUrl.value;
                state.blockData.fallbackImageUrl = elements.fallbackImageUrl.value;
                state.blockData.fallbackLinkUrl = elements.fallbackLinkUrl.value;
                refreshPreview();
            }
        }, moduleConfig.debounceDelay);

        function updateUI() {
            elements.backgroundImageUrl.value = utils.getFieldValue('backgroundImageUrl');
            elements.fallbackImageUrl.value = utils.getFieldValue('fallbackImageUrl');
            elements.fallbackLinkUrl.value = utils.getFieldValue('fallbackLinkUrl');
            elements.previewImage.src = utils.getFieldValue('backgroundImageUrl');

            elements.itemsContainer.replaceChildren();
            const hotspots = utils.getFieldValue('hotspots');
            hotspots.forEach((hotspot, index) => {
                const fragment = elements.itemTemplate.content.cloneNode(true);
                const el = fragment.querySelector('.item');
                el.dataset.id = hotspot.id;
                el.classList.toggle('selected', hotspot.id === state.selectedHotspotId);
                el.querySelector('.item-title').textContent = `Hotspot ${index + 1}`;
                
                const textInput = el.querySelector('[data-field="text"]');
                const textError = el.querySelector('.field-error');
                textInput.value = hotspot.text;

                // Set up validation for text input
                const validationRules = [
                    Validator.rules.length(100),
                    Validator.rules.noHtml,
                    Validator.rules.required
                ];

                // Setup real-time validation
                Validator.setupRealTimeValidation(textInput, validationRules, textError);

                // Enhanced input handler with validation
                const handleTextInput = (e) => {
                    const isValid = Validator.validateField(e.target, validationRules, textError);
                    
                    // Only update data if valid
                    if (isValid) {
                        updateHotspotData();
                    }
                };

                textInput.addEventListener('input', handleTextInput);
                textInput.addEventListener('blur', handleTextInput);

                const posButton = el.querySelector(`.position-button[data-position="${hotspot.tooltipPosition}"]`);
                if (posButton) posButton.classList.add('selected');

                el.querySelector('.move-up-btn').disabled = (index === 0);
                el.querySelector('.move-down-btn').disabled = (hotspots.length === 1 || index === hotspots.length - 1);

                elements.itemsContainer.appendChild(fragment);
            });

            elements.visualEditor.querySelectorAll('.hotspot-marker').forEach(m => m.remove());
            hotspots.forEach(hotspot => {
                const marker = document.createElement('div');
                marker.className = 'hotspot-marker';
                marker.dataset.id = hotspot.id;
                marker.style.left = `${hotspot.posX}%`;
                marker.style.top = `${hotspot.posY}%`;
                marker.classList.toggle('selected', hotspot.id === state.selectedHotspotId);
                elements.visualEditor.appendChild(marker);
            });
        }

        function getTooltipCss(position) {
            switch (position) {
                case 'top-left':     return 'left: 0; top: 0; transform: translate(-100%, -100%) translateY(-10px) translateX(-10px);';
                case 'top':          return 'left: 50%; top: 0; transform: translate(-50%, -100%) translateY(-10px);';
                case 'top-right':    return 'left: 100%; top: 0; transform: translate(0, -100%) translateY(-10px) translateX(10px);';
                case 'left':         return 'left: 0; top: 50%; transform: translate(-100%, -50%) translateX(-10px);';
                case 'right':        return 'left: 100%; top: 50%; transform: translate(0, -50%) translateX(10px);';
                case 'bottom-left':  return 'left: 0; top: 100%; transform: translate(-100%, 0) translateY(10px) translateX(-10px);';
                case 'bottom':       return 'left: 50%; top: 100%; transform: translate(-50%, 0) translateY(10px);';
                case 'bottom-right': return 'left: 100%; top: 100%; transform: translate(0, 0) translateY(10px) translateX(10px);';
                case 'center':
                default:             return 'left: 50%; top: 50%; transform: translate(-50%, -50%);';
            }
        }

        function generateTemplate() {
            const bgImg = utils.getFieldValue('backgroundImageUrl');
            const fallbackImg = utils.getFieldValue('fallbackImageUrl');
            const fallbackLink = utils.getFieldValue('fallbackLinkUrl');
            const hotspots = utils.getFieldValue('hotspots');

            const interactiveHotspots = hotspots.map((h, i) => `
            <div class="hot-tool-wrapper" style="position: absolute; left: ${h.posX}%; top: ${h.posY}%; z-index: ${i+1};">
              <img alt="" border="0" height="36" src="https://image.mail.milwaukeetool.eu/lib/fe2f11717564047a761c78/m/1/ba4b84d2-b601-42a6-a8e3-e2f32eb1100c.png" style="display: block; width: 36px; height: 36px;" width="36">
              <div class="tooltip-wrapper" style="position: absolute; width: 200px; z-index: 99; background-color: rgba(0, 0, 0, 0.8); display: none; max-height: 0; opacity: 0; overflow: hidden; padding: 10px; text-align: center; transition: all 0.3s ease; border-radius: 4px; ${getTooltipCss(h.tooltipPosition)}">
                <span style="color: #ffffff; font-family: 'Helvetica Neue LT W05_55 Roman', sans-serif, 'Open-Sans'; font-size: 20px; font-weight: bold; line-height: 26px; text-transform: uppercase;">${h.text}</span>
              </div>
            </div>`).join('');

            const fallbackItems = hotspots.map(h => `
                   <tr>
                    <td valign="top" style="padding-bottom: 8px; width: 20px;"><img alt="" src="https://image.mail.milwaukeetool.eu/lib/fe2f11717564047a761c78/m/1/06914a54-6462-4ecd-a8bf-74c46518351d.png" style="display: block; height: auto;" width="20"></td>
                    <td style="width: 12px; padding-bottom: 8px;"> </td>
                    <td style="color: #ffffff; font-family: 'Helvetica-Neue', sans-serif, 'Open-Sans'; font-size: 16px; font-weight: normal; line-height: 24px; text-align: left;">${h.text}</td>
                   </tr>`).join('');

            return `<style type="text/css">
              .hot-tool-wrapper:hover .tooltip-wrapper { display: block !important; max-height: 200px !important; opacity: 1 !important; }
              .hotspots-fallback { display: none; max-height: 0; overflow: hidden; }
              @media screen and (max-width: 580px) {
                .hotspots-interactive { display: none !important; }
                .hotspots-fallback { display: block !important; max-height: none !important; overflow: visible !important; }
              }
            </style>
            <!--[if !mso]><!-->
            <div class="hotspots-interactive" style="background-color: #DB021d;"><div style="background-image: url('${bgImg}'); background-position: center; background-repeat: no-repeat; background-size: contain; height: 500px; position: relative; max-width: 620px; margin: 0 auto;">${interactiveHotspots}</div></div>
            <!--<![endif]-->
            <div class="hotspots-fallback">
              <table align="center" border="0" cellpadding="0" cellspacing="0" role="presentation" style="width: 100%; max-width: 620px; background-color: #DB021d;">
                <tr><td align="center"><a href="${fallbackLink}" target="_blank"><img alt="" src="${fallbackImg}" style="display: block; width: 100%; max-width: 620px; height: auto;" width="620"></a></td></tr>
                <tr><td style="padding: 0 20px;"><div style="font-size: 20px; height: 20px;"> </div><table role="presentation" border="0" cellpadding="0" cellspacing="0" width="100%">${fallbackItems}</table><div style="font-size: 20px; height: 20px;"> </div></td></tr>
              </table>
            </div>`;
        }

        function refreshPreview() {
            if (rafId) cancelAnimationFrame(rafId);

            rafId = requestAnimationFrame(() => {
                if (!state.sdk) return;
                try {
                    state.sdk.setContent(generateTemplate());
                    state.sdk.setData({ ...state.blockData });
                } catch (error) { console.error(`Preview update failed: ${error.message}`); }
            });
        }

        function initializeEventHandlers() {
            // Set up validation for global fields
            const globalFields = [
                { element: elements.backgroundImageUrl, rules: [Validator.rules.url] },
                { element: elements.fallbackImageUrl, rules: [Validator.rules.url] },
                { element: elements.fallbackLinkUrl, rules: [Validator.rules.url] }
            ];
            
            globalFields.forEach(({ element, rules }) => {
                const errorElement = element.closest('.field-group')?.querySelector('.field-error');
                Validator.setupRealTimeValidation(element, rules, errorElement);
                element.addEventListener('input', updateStateFromUI);
            });

            elements.addItemBtn.addEventListener('click', createHotspotDelegatedHandler(hotspotActions));

            elements.visualEditor.addEventListener('click', (e) => {
                const targetIsMarker = e.target.classList.contains('hotspot-marker');
                if (targetIsMarker) {
                    state.selectedHotspotId = e.target.dataset.id;
                    updateUI();
                    return;
                }
                if (!state.selectedHotspotId) {
                    alert('Please select a hotspot from the list below before placing it.');
                    return;
                }
                const rect = elements.previewImage.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const hotspot = state.blockData.hotspots.find(h => h.id === state.selectedHotspotId);
                if (hotspot) {
                    hotspot.posX = parseFloat(((x / rect.width) * 100).toFixed(2));
                    hotspot.posY = parseFloat(((y / rect.height) * 100).toFixed(2));
                    updateUI();
                    refreshPreview();
                }
            });

            // Optimized Event Delegation with Action Maps
            const hotspotActions = {
                '.remove-btn': (hotspot, index, hotspots) => {
                    const newHotspots = hotspots.filter(h => h.id !== hotspot.id);
                    state.blockData.hotspots = newHotspots;
                    if (state.selectedHotspotId === hotspot.id) {
                        state.selectedHotspotId = newHotspots.length > 0 ? newHotspots[0].id : null;
                    }
                    return true;
                },
                '.move-up-btn': (hotspot, index, hotspots) => {
                    if (index > 0) {
                        [hotspots[index], hotspots[index - 1]] = [hotspots[index - 1], hotspots[index]];
                        return true;
                    }
                    return false;
                },
                '.move-down-btn': (hotspot, index, hotspots) => {
                    if (index < hotspots.length - 1) {
                        [hotspots[index], hotspots[index + 1]] = [hotspots[index + 1], hotspots[index]];
                        return true;
                    }
                    return false;
                },
                '.position-button': (hotspot, index, hotspots, context) => {
                    hotspot.tooltipPosition = context.target.dataset.position;
                    return true;
                }
            };

            function createHotspotDelegatedHandler(actionMap) {
                return (event) => {
                    // Handle add button clicks
                    if (event.target.closest('#addItemBtn')) {
                        const newHotspot = { 
                            id: crypto.randomUUID(), 
                            text: 'New Hotspot', 
                            posX: 50, 
                            posY: 50, 
                            tooltipPosition: 'top' 
                        };
                        state.blockData.hotspots.push(newHotspot);
                        state.selectedHotspotId = newHotspot.id;
                        updateUI();
                        refreshPreview();
                        return;
                    }

                    // Find the closest item element
                    const itemEl = event.target.closest('.item');
                    if (!itemEl) return;

                    const id = itemEl.dataset.id;
                    const hotspots = state.blockData.hotspots;
                    const hotspotIndex = hotspots.findIndex(h => h.id === id);

                    if (hotspotIndex === -1) return;

                    const hotspot = hotspots[hotspotIndex];
                    const controlButton = event.target.closest('.item-control-btn, .position-button');

                    if (controlButton) {
                        event.stopPropagation();
                        let actionExecuted = false;

                        // Execute action using action map
                        for (const [selector, action] of Object.entries(actionMap)) {
                            if (controlButton.matches(selector)) {
                                const context = { target: event.target };
                                const result = action(hotspot, hotspotIndex, hotspots, context);

                                if (result) {
                                    actionExecuted = true;
                                    updateUI();
                                    refreshPreview();
                                }
                                break;
                            }
                        }

                        if (!actionExecuted) {
                            console.log('No matching action found for selector');
                        }
                        return;
                    }

                    // Handle item selection
                    if (state.selectedHotspotId !== id) {
                        state.selectedHotspotId = id;
                        updateUI();
                    }
                };
            }


            elements.itemsContainer.addEventListener('click', createHotspotDelegatedHandler(hotspotActions));

            elements.itemsContainer.addEventListener('input', utils.debounce((e) => {
                const itemEl = e.target.closest('.item');
                if (!itemEl) return;
                const id = itemEl.dataset.id;
                const hotspot = state.blockData.hotspots.find(h => h.id === id);
                if(hotspot) {
                    hotspot.text = itemEl.querySelector('[data-field="text"]').value;
                    refreshPreview();
                }
            }, moduleConfig.debounceDelay));
        }

        function loadData() {
            setLoadingState(true);
            state.sdk.getData((data) => {
                const newBlockData = {};
                Object.keys(moduleConfig.fields).forEach(key => {
                    const savedValue = data && data[key];
                    if (savedValue !== undefined) {
                        newBlockData[key] = savedValue;
                    } else {
                        const defaultValue = moduleConfig.fields[key].defaultValue;
                        newBlockData[key] = Array.isArray(defaultValue) ? defaultValue.map(item => ({ ...item, id: crypto.randomUUID() })) : defaultValue;
                    }
                });
                state.blockData = newBlockData;

                if(state.blockData.hotspots) {
                    state.blockData.hotspots.forEach(h => { if(!h.id) h.id = crypto.randomUUID(); });
                }

                if (!state.selectedHotspotId && state.blockData.hotspots && state.blockData.hotspots.length > 0) {
                    state.selectedHotspotId = state.blockData.hotspots[0].id;
                }

                updateUI();
                refreshPreview();
                setLoadingState(false);
            });
        }

        // Enhanced cleanup function
        function cleanup() {
            // Clean up event listeners
            state.eventListeners.forEach(({ element, event, handler }) => { 
                if (element && element.removeEventListener) element.removeEventListener(event, handler); 
            }); 
            state.eventListeners = [];

            // Cancel any pending RAF
            if (rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }

            // Clear DOM cache
            DOMCache.clear();

            console.log('Hotspots cleanup completed');
        }

        function initialize() {
            try {
                if (!window.sfdc || !window.sfdc.BlockSDK) throw new Error('BlockSDK not loaded');
                state.sdk = new window.sfdc.BlockSDK({
                    tabs: ['htmlblock']
                });
                cacheElements();
                initializeEventHandlers();
                loadData();

                // Add cleanup on page unload
                window.addEventListener('beforeunload', cleanup);

                // Add automatic cleanup on visibility change
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        console.log('Tab hidden - pausing expensive operations');
                        
                        // Pause expensive operations
                        if (rafId) {
                            cancelAnimationFrame(rafId);
                            rafId = null;
                        }
                        
                        // Clear caches to free memory
                        DOMCache.clear();
                        
                        // Run garbage collection hint if available
                        if (window.gc) {
                            console.log('Running garbage collection hint');
                            window.gc();
                        }
                    } else {
                        console.log('Tab visible - resuming operations');
                        
                        // Resume operations if needed
                        if (state.sdk && !state.isLoading) {
                            // Recache elements after clearing
                            cacheElements();
                            
                            // Refresh preview to ensure sync
                            refreshPreview();
                            
                            console.log('Operations resumed');
                        }
                    }
                });
                
            } catch (error) {
                console.error(`Initialization failed: ${error.message}`);
                setLoadingState(false);
            }
        }

        document.readyState === 'loading' ? document.addEventListener('DOMContentLoaded', initialize) : initialize();
    </script>
</body>
</html>