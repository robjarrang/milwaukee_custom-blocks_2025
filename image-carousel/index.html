<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Interactive C            <div class="field-group">
                <label class="field-label">Image URL (620x350px)</label>
                <div class="field-input-wrapper">
                    <input type="url" class="field-input" data-field="imageUrl" placeholder="https://placehold.co/620x350" required aria-describedby="imageUrl-error">
                    <span class="validation-icon error">✗</span>
                </div>
                <div class="field-error" id="imageUrl-error" role="alert"></div>
            </div>
            <div class="field-group">
                <label class="field-label">Link URL</label>
                <div class="field-input-wrapper">
                    <input type="url" class="field-input" data-field="linkUrl" placeholder="https://example.com/product" aria-describedby="linkUrl-error">
                    <span class="validation-icon error">✗</span>
                </div>
                <div class="field-error" id="linkUrl-error" role="alert"></div>
            </div>
            <div class="field-group">
                <label class="field-label">Alt Text</label>
                <div class="field-input-wrapper">
                    <input type="text" class="field-input" data-field="altText" placeholder="Descriptive text for accessibility" maxlength="100" aria-describedby="altText-error">
                    <span class="validation-icon error">✗</span>
                </div>
                <div class="field-error" id="altText-error" role="alert"></div>
            </div>/title>
    <link rel="stylesheet" href="https://cloud.mail.milwaukeetool.eu/customblock-styles">
    <style>
        body{margin:0;padding:20px;font-family:Arial,sans-serif;background-color:#f5f5f5}.container{max-width:800px;margin:0 auto;background:white;padding:20px;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,0.1);transition:opacity 0.3s ease}.container.loading{opacity:0.6;pointer-events:none}.field-group{margin-bottom:15px}.field-label{display:block;margin-bottom:5px;font-weight:bold;color:#333;font-size:14px}.field-input{width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:4px;font-size:14px;box-sizing:border-box;transition:border-color 0.3s ease}.field-input:focus{outline:none;border-color:#0074d9;box-shadow:0 0 0 2px rgba(0,116,217,0.2)}.section-divider{margin-top:30px;padding-top:20px;border-top:2px solid #eee}.section-title{font-size:16px;font-weight:bold;color:#333;margin-bottom:15px;border-bottom:2px solid #eee;padding-bottom:10px}.slides-container{display:flex;flex-direction:column;gap:15px}.slide-item{background-color:#fafafa;padding:20px;border:1px solid #ddd;border-radius:6px;position:relative}.slide-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}.slide-title{font-weight:bold;font-size:16px;margin:0}.slide-controls{display:flex;gap:8px}.slide-control-btn{background:none;border:none;cursor:pointer;padding:5px;font-size:18px;line-height:1;color:#555;transition:color .2s}.slide-control-btn:hover{color:#0074d9}.slide-control-btn:disabled{color:#ccc;cursor:not-allowed}.btn{display:inline-block;padding:10px 15px;background-color:#0074d9;color:white;text-decoration:none;border-radius:4px;border:none;cursor:pointer;font-size:14px;font-weight:bold;transition:background-color .2s}.btn:hover{background-color:#005a9e}.add-slide-btn{margin-top:20px}.loading-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(255,255,255,0.9);display:none;align-items:center;justify-content:center;z-index:9999}.loading-overlay.show{display:flex}.loading-spinner{border:3px solid #f3f3f3;border-top:3px solid #0074d9;border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.error-banner{background-color:#fee;border:1px solid #fcc;color:#c00;padding:10px;margin-bottom:20px;border-radius:4px;display:none}.error-banner.show{display:block}
        
        /* Enhanced validation styles */
        .field-input.error{border-color:#dc3545;background-color:#fff5f5;box-shadow:0 0 0 2px rgba(220,53,69,0.2)}
        .field-error{color:#dc3545;font-size:12px;margin-top:4px;display:none;font-weight:500}
        .field-error.show{display:block}
        
        /* Validation icons */
        .field-input-wrapper{position:relative}
        .field-input-wrapper .validation-icon{position:absolute;right:10px;top:50%;transform:translateY(-50%);font-size:16px;pointer-events:none;opacity:0;transition:opacity 0.3s ease}
        .field-input.error + .validation-icon.error{opacity:1;color:#dc3545}
        
        /* Real-time feedback animations */
        .field-input{transition:all 0.3s ease}
        .field-input.error{animation:shake 0.5s ease-in-out}
        
        @keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}
        /* Screen reader only content */
        .sr-only {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            border: 0 !important;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay"><div class="loading-spinner"></div></div>

        <div class="container" id="mainContainer" role="main" aria-labelledby="main-heading">
        <h1 id="main-heading" class="section-title">Interactive Carousel Slides</h1>
        <div id="slidesContainer" class="slides-container">
            <!-- Slides will be dynamically inserted here -->
        </div>
        <button id="addSlideBtn" class="btn add-slide-btn" aria-describedby="add-slide-help">Add New Slide</button>
        <div id="add-slide-help" class="sr-only">Adds a new slide to the end of the carousel</div>
    </div>

    <!-- Template for a single slide's UI -->
    <template id="slideTemplate">
        <div class="slide-item">
            <div class="slide-header">
                <h3 class="slide-title">Slide</h3>
                <div class="slide-controls">
                    <button class="slide-control-btn move-up-btn" title="Move Up">▲</button>
                    <button class="slide-control-btn move-down-btn" title="Move Down">▼</button>
                    <button class="slide-control-btn remove-btn" title="Remove Slide">×</button>
                </div>
            </div>
            <div class="field-group">
                <label class="field-label">Image URL (620x350px)</label>
                <input type="url" class="field-input" data-field="imageUrl" placeholder="https://placehold.co/620x350">
                <div class="field-error">Please enter a valid image URL.</div>
            </div>
            <div class="field-group">
                <label class="field-label">Link URL</label>
                <input type="url" class="field-input" data-field="linkUrl" placeholder="https://example.com/product">
                <div class="field-error">Please enter a valid link URL.</div>
            </div>
            <div class="field-group">
                <label class="field-label">Image Alt Text</label>
                <input type="text" class="field-input" data-field="altText" placeholder="Descriptive text for accessibility">
            </div>
        </div>
    </template>

    <script src="https://cloud.mail.milwaukeetool.eu/customblock-base"></script>
    <script src="https://cloud.mail.milwaukeetool.eu/customblock-blocksdk"></script>
    <script>
        'use strict';

        const moduleConfig = {
            name: 'Interactive Carousel',
            fields: {
                slides: {
                    type: 'list',
                    defaultValue: [
                        { id: crypto.randomUUID(), imageUrl: 'https://placehold.co/620x350/DB021D/FFFFFF?text=Slide+1', linkUrl: 'https://example.com/1', altText: 'Slide 1 Alt Text' },
                        { id: crypto.randomUUID(), imageUrl: 'https://placehold.co/620x350/313131/FFFFFF?text=Slide+2', linkUrl: 'https://example.com/2', altText: 'Slide 2 Alt Text' }
                    ]
                },
                fallbackImageUrl: { type: 'url', defaultValue: '' },
                fallbackLinkUrl: { type: 'url', defaultValue: '' },
                fallbackAltText: { type: 'text', defaultValue: '' }
            },
            debounceDelay: 400,
            maxRetries: 3
        };

        const state = { sdk: null, blockData: {}, isLoading: false, isInitialized: false, retryCount: 0, eventListeners: [] };
        const elements = {};

        // Create a DOM cache utility to consolidate repeated DOM queries
        const DOMCache = {
            cache: new Map(),
            get(selector) {
                if (!this.cache.has(selector)) {
                    this.cache.set(selector, document.querySelector(selector));
                }
                return this.cache.get(selector);
            },
            getAll(selector) {
                if (!this.cache.has(selector + '_all')) {
                    this.cache.set(selector + '_all', document.querySelectorAll(selector));
                }
                return this.cache.get(selector + '_all');
            },
            clear() { this.cache.clear(); },
            clearDynamic() {
                const dynamicKeys = Array.from(this.cache.keys()).filter(key => 
                    key.includes('.image-item') || key.includes('[data-')
                );
                dynamicKeys.forEach(key => this.cache.delete(key));
            }
        };

        // Utility for retryable operations
        const RetryableOperation = {
            async execute(operation, options = {}) {
                const { maxRetries = 3, delay = 1000, backoff = 2, onRetry = () => {} } = options;
                let lastError;
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        return await operation();
                    } catch (error) {
                        lastError = error;
                        if (i < maxRetries - 1) {
                            onRetry(i + 1, error);
                            await new Promise(resolve => setTimeout(resolve, delay * Math.pow(backoff, i)));
                        }
                    }
                }
                throw lastError;
            }
        };

        // Enhanced validation utility
        const Validator = {
            rules: {
                url: (value) => !value || utils.isValidUrl(value),
                email: (value) => !value || /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
                number: (min, max) => (value) => {
                    const num = parseFloat(value);
                    return !isNaN(num) && num >= min && num <= max;
                },
                length: (max) => (value) => !value || value.length <= max,
                required: (value) => value && value.trim().length > 0,
                alphanumeric: (value) => !value || /^[a-zA-Z0-9\s]+$/.test(value),
                noHtml: (value) => !value || !/[<>]/.test(value)
            },
            
            validateField(input, rules, errorElement = null) {
                const isValid = rules.every(rule => rule(input.value));
                
                // Visual feedback
                input.classList.toggle('error', !isValid);
                
                // Add aria-invalid for accessibility
                input.setAttribute('aria-invalid', !isValid);
                
                // Show/hide error message if error element provided
                if (errorElement) {
                    errorElement.style.display = isValid ? 'none' : 'block';
                    if (!isValid) {
                        errorElement.textContent = this.getErrorMessage(input, rules);
                    }
                }
                
                return isValid;
            },
            
            getErrorMessage(input, rules) {
                const value = input.value;
                
                if (rules.includes(this.rules.required) && !value.trim()) {
                    return 'This field is required';
                }
                if (rules.includes(this.rules.url) && !this.rules.url(value)) {
                    return 'Please enter a valid URL (http:// or https://)';
                }
                if (rules.includes(this.rules.email) && !this.rules.email(value)) {
                    return 'Please enter a valid email address';
                }
                if (rules.some(rule => rule.toString().includes('length')) && value.length > 0) {
                    const maxLength = input.getAttribute('maxlength') || '100';
                    return `Maximum ${maxLength} characters allowed`;
                }
                if (rules.includes(this.rules.noHtml) && !this.rules.noHtml(value)) {
                    return 'HTML tags are not allowed';
                }
                
                return 'Invalid input';
            },
            
            // Real-time validation setup
            setupRealTimeValidation(input, rules, errorElement = null) {
                const validateInput = () => {
                    return this.validateField(input, rules, errorElement);
                };
                
                // Validate on input (immediate feedback)
                input.addEventListener('input', validateInput);
                
                // Validate on blur (final check)
                input.addEventListener('blur', validateInput);
                
                // Initial validation if field has value
                if (input.value) {
                    validateInput();
                }
                
                return validateInput;
            },
            
            // Validate all form fields
            validateAll(container = document) {
                const inputs = container.querySelectorAll('.field-input[data-field]');
                let allValid = true;
                
                inputs.forEach(input => {
                    const rules = [];
                    
                    // Add rules based on input attributes and type
                    if (input.hasAttribute('required') || input.dataset.field === 'imageUrl') {
                        rules.push(this.rules.required);
                    }
                    if (input.type === 'url') {
                        rules.push(this.rules.url);
                    }
                    if (input.type === 'email') {
                        rules.push(this.rules.email);
                    }
                    if (input.hasAttribute('maxlength')) {
                        const max = parseInt(input.getAttribute('maxlength'));
                        rules.push(this.rules.length(max));
                    }
                    
                    // Always check for HTML
                    rules.push(this.rules.noHtml);
                    
                    const errorElement = input.closest('.field-group')?.querySelector('.field-error');
                    const isValid = this.validateField(input, rules, errorElement);
                    
                    if (!isValid) {
                        allValid = false;
                    }
                });
                
                return allValid;
            }
        };

        let rafId = null;

        // Enhanced memory management with weak references for slides
        const cleanupRegistry = new FinalizationRegistry((heldValue) => {
            console.log('Cleanup registry triggered for slide:', heldValue);
            SlideManager.cleanup();
        });

        // Enhanced memory management for slide elements
        const SlideManager = {
            slides: new WeakMap(),
            references: new Map(),
            metadata: new Map(),
            
            register(id, slideElement, metadata = {}) {
                const ref = new WeakRef(slideElement);
                this.references.set(id, ref);
                this.slides.set(slideElement, {
                    id,
                    ...metadata,
                    created: Date.now(),
                    lastAccessed: Date.now()
                });
                this.metadata.set(id, {
                    id,
                    ...metadata,
                    created: Date.now(),
                    element: slideElement
                });
                
                // Register for cleanup
                cleanupRegistry.register(slideElement, id);
                
                console.log(`Slide ${id} registered with enhanced memory management`);
                return ref;
            },
            
            get(id) {
                const ref = this.references.get(id);
                if (ref) {
                    const slide = ref.deref();
                    if (slide) {
                        // Update last accessed time
                        const slideData = this.slides.get(slide);
                        if (slideData) {
                            slideData.lastAccessed = Date.now();
                        }
                        return slide;
                    } else {
                        // Slide was garbage collected
                        console.log(`Slide ${id} was garbage collected`);
                        this.references.delete(id);
                        this.metadata.delete(id);
                    }
                }
                return null;
            },
            
            has(id) {
                const ref = this.references.get(id);
                return ref && ref.deref() !== undefined;
            },
            
            delete(id) {
                const ref = this.references.get(id);
                if (ref) {
                    const slide = ref.deref();
                    if (slide) {
                        this.slides.delete(slide);
                    }
                }
                this.references.delete(id);
                this.metadata.delete(id);
                console.log(`Slide ${id} removed from memory management`);
            },
            
            cleanup() {
                // Clean up dead references
                let cleaned = 0;
                for (const [id, ref] of this.references) {
                    if (!ref.deref()) {
                        this.references.delete(id);
                        this.metadata.delete(id);
                        cleaned++;
                    }
                }
                if (cleaned > 0) {
                    console.log(`Cleaned up ${cleaned} dead slide references`);
                }
                return cleaned;
            },
            
            getStats() {
                const alive = Array.from(this.references.values())
                    .filter(ref => ref.deref()).length;
                return {
                    total: this.references.size,
                    alive,
                    dead: this.references.size - alive,
                    metadata: this.metadata.size
                };
            },
            
            // Clear all references
            clear() {
                this.references.clear();
                this.metadata.clear();
                this.slides = new WeakMap();
                console.log('All slide references cleared');
            }
        };

        const utils = {
            debounce(func, wait) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => func.apply(this, a), wait); }; },
            isValidUrl(s) { if (!s || s.trim() === '') return true; try { const u = new URL(s); return u.protocol === 'http:' || u.protocol === 'https:'; } catch (e) { return false; } },
            showError(msg, p = false) { console.error(msg); if(elements.errorBanner) { elements.errorBanner.textContent=msg; elements.errorBanner.classList.add('show'); if(!p) setTimeout(()=>elements.errorBanner.classList.remove('show'),5000); } },
            getFieldValue(f) { const v = state.blockData[f]; return v !== undefined ? v : moduleConfig.fields[f].defaultValue; },

            addEventListenerTracked(element, event, handler) {
                element.addEventListener(event, handler);
                state.eventListeners.push({ element, event, handler });
            }
        };

        function cacheElements() {
            elements.mainContainer = document.getElementById('mainContainer');
            elements.loadingOverlay = document.getElementById('loadingOverlay');
            elements.errorBanner = document.getElementById('errorBanner');
            elements.slidesContainer = document.getElementById('slidesContainer');
            elements.addSlideBtn = document.getElementById('addSlideBtn');
            elements.slideTemplate = document.getElementById('slideTemplate');
            elements.fallbackImageUrl = document.getElementById('fallbackImageUrl');
            elements.fallbackLinkUrl = document.getElementById('fallbackLinkUrl');
            elements.fallbackAltText = document.getElementById('fallbackAltText');
            elements.fallbackImageUrlError = elements.fallbackImageUrl.nextElementSibling;
            elements.fallbackLinkUrlError = elements.fallbackLinkUrl.nextElementSibling;
        }

        function setLoadingState(loading) {
            state.isLoading = loading;
            elements.mainContainer.classList.toggle('loading', loading);
            elements.loadingOverlay.classList.toggle('show', loading);
        }

        function updateDataFromUI() {
            // Validate all fields before updating
            const isFormValid = Validator.validateAll(elements.slidesContainer);
            
            // Validate global fallback fields
            const globalFields = [
                { element: elements.fallbackImageUrl, rules: [Validator.rules.url] },
                { element: elements.fallbackLinkUrl, rules: [Validator.rules.url] },
                { element: elements.fallbackAltText, rules: [Validator.rules.length(100), Validator.rules.noHtml] }
            ];
            
            let globalValid = true;
            globalFields.forEach(({ element, rules }) => {
                const errorElement = element.closest('.field-group')?.querySelector('.field-error');
                if (!Validator.validateField(element, rules, errorElement)) {
                    globalValid = false;
                }
            });
            
            // Use DocumentFragment for efficient DOM operations and modern array methods
            const newSlides = Array.from(
                elements.slidesContainer.querySelectorAll('.slide-item'),
                slideEl => {
                    const id = slideEl.dataset.id;
                    const imageUrl = slideEl.querySelector('[data-field="imageUrl"]').value;
                    const linkUrl = slideEl.querySelector('[data-field="linkUrl"]').value;
                    const altText = slideEl.querySelector('[data-field="altText"]').value;
                    
                    // Only include valid slides
                    const imageInput = slideEl.querySelector('[data-field="imageUrl"]');
                    if (imageInput && !imageInput.classList.contains('error') && imageUrl.trim()) {
                        return { id, imageUrl, linkUrl, altText };
                    }
                    return null;
                }
            ).filter(Boolean); // Remove null entries

            // Only update if valid
            if (isFormValid && globalValid && newSlides.length > 0) {
                state.blockData.slides = newSlides;
                state.blockData.fallbackImageUrl = elements.fallbackImageUrl.value;
                state.blockData.fallbackLinkUrl = elements.fallbackLinkUrl.value;
                state.blockData.fallbackAltText = elements.fallbackAltText.value;
                refreshPreview();
            } else if (newSlides.length === 0 && isFormValid && globalValid) {
                // Show empty state but don't break functionality
                state.blockData.slides = [];
                refreshPreview();
            }
        }

        const debouncedUpdateDataFromUI = utils.debounce(updateDataFromUI, moduleConfig.debounceDelay);

        function renderSlidesUI() {
            const slides = utils.getFieldValue('slides');

            if (!slides || slides.length === 0) {
                elements.slidesContainer.replaceChildren();
                return;
            }

            // Use DocumentFragment for batch DOM operations
            const fragment = document.createDocumentFragment();

            slides.forEach((slide, index) => {
                const slideFragment = elements.slideTemplate.content.cloneNode(true);
                const slideEl = slideFragment.querySelector('.slide-item');
                slideEl.dataset.id = slide.id;
                slideEl.querySelector('.slide-title').textContent = `Slide ${index + 1}`;
                
                const imageInput = slideEl.querySelector('[data-field="imageUrl"]');
                const linkInput = slideEl.querySelector('[data-field="linkUrl"]');
                const altInput = slideEl.querySelector('[data-field="altText"]');
                
                imageInput.value = slide.imageUrl || '';
                linkInput.value = slide.linkUrl || '';
                altInput.value = slide.altText || '';

                // Set up validation for each field
                const imageError = slideEl.querySelector('#imageUrl-error');
                const linkError = slideEl.querySelector('#linkUrl-error');
                const altError = slideEl.querySelector('#altText-error');

                // Image URL validation (required)
                const imageRules = [Validator.rules.required, Validator.rules.url];
                Validator.setupRealTimeValidation(imageInput, imageRules, imageError);
                
                // Link URL validation (optional)
                const linkRules = [Validator.rules.url];
                Validator.setupRealTimeValidation(linkInput, linkRules, linkError);
                
                // Alt text validation
                const altRules = [Validator.rules.length(100), Validator.rules.noHtml];
                Validator.setupRealTimeValidation(altInput, altRules, altError);

                // Enhanced input handlers with validation
                [imageInput, linkInput, altInput].forEach(input => {
                    const rules = input === imageInput ? imageRules : 
                                 input === linkInput ? linkRules : altRules;
                    const errorElement = input.closest('.field-group')?.querySelector('.field-error');
                    
                    const handleInput = (e) => {
                        const isValid = Validator.validateField(e.target, rules, errorElement);
                        
                        // Only update data if valid
                        if (isValid) {
                            debouncedUpdateDataFromUI();
                        }
                    };

                    input.addEventListener('input', handleInput);
                    input.addEventListener('blur', handleInput);
                });

                if(index === 0) slideEl.querySelector('.move-up-btn').disabled = true;
                if(index === slides.length - 1) slideEl.querySelector('.move-down-btn').disabled = true;

                fragment.appendChild(slideFragment);

                // Track slide metadata with enhanced memory management
                SlideManager.register(slide.id, slideEl, {
                    id: slide.id,
                    index,
                    element: slideEl
                });
            });

            // Single DOM update
            elements.slidesContainer.replaceChildren();
            elements.slidesContainer.appendChild(fragment);
        }

        // Optimized Event Delegation with Action Maps
        const slideActions = {
            '.remove-btn': (slide, index, slides) => {
                slides.splice(index, 1);
                return true;
            },
            '.move-up-btn': (slide, index, slides) => {
                if (index > 0) {
                    [slides[index], slides[index - 1]] = [slides[index - 1], slides[index]];
                    return true;
                }
                return false;
            },
            '.move-down-btn': (slide, index, slides) => {
                if (index < slides.length - 1) {
                    [slides[index], slides[index + 1]] = [slides[index + 1], slides[index]];
                    return true;
                }
                return false;
            },
            '.duplicate-btn': (slide, index, slides) => {
                const newSlide = { ...slide, id: crypto.randomUUID() };
                slides.splice(index + 1, 0, newSlide);
                return true;
            }
        };

        function createDelegatedHandler(fieldName, actionMap) {
            return (event) => {
                // Handle add button clicks
                if (event.target.closest('#addSlideBtn')) {
                    const currentSlides = utils.getFieldValue(fieldName);
                    const newSlides = [...currentSlides, { id: crypto.randomUUID(), imageUrl: '', linkUrl: '', altText: '' }];
                    state.blockData[fieldName] = newSlides;
                    renderSlidesUI();
                    updateDataFromUI();
                    return;
                }

                // Find the closest slide element
                const slideEl = event.target.closest('.slide-item');
                if (!slideEl) return;

                const id = slideEl.dataset.id;
                const currentSlides = state.blockData[fieldName];
                const slideIndex = currentSlides.findIndex(s => s.id === id);

                if (slideIndex === -1) return;

                const slide = currentSlides[slideIndex];
                let actionExecuted = false;

                // Execute action using action map
                for (const [selector, action] of Object.entries(actionMap)) {
                    if (event.target.closest(selector)) {
                        const result = action(slide, slideIndex, currentSlides);

                        if (result) {
                            actionExecuted = true;
                            renderSlidesUI();
                            updateDataFromUI();
                        }
                        break;
                    }
                }

                if (!actionExecuted) {
                    console.log('No matching action found for selector');
                }
            };
        }

        function initializeEventHandlers() {
            // Set up validation for global fallback fields
            const globalFields = [
                { element: elements.fallbackImageUrl, rules: [Validator.rules.url] },
                { element: elements.fallbackLinkUrl, rules: [Validator.rules.url] },
                { element: elements.fallbackAltText, rules: [Validator.rules.length(100), Validator.rules.noHtml] }
            ];
            
            globalFields.forEach(({ element, rules }) => {
                const errorElement = element.closest('.field-group')?.querySelector('.field-error');
                Validator.setupRealTimeValidation(element, rules, errorElement);
                element.addEventListener('input', debouncedUpdateDataFromUI);
            });

            // Optimized event delegation for slide items
            const slideHandler = createDelegatedHandler('slides', slideActions);

            utils.addEventListenerTracked(elements.addSlideBtn, 'click', slideHandler);
            utils.addEventListenerTracked(elements.slidesContainer, 'click', slideHandler);
        }

        function generateTemplate() {
            const slides = utils.getFieldValue('slides');
            if (!slides || slides.length === 0) {
                return '<table align="center" style="width:620px; height:350px; background-color:#ccc;"><tr><td style="text-align:center;font-family:Arial,sans-serif;">Add slides to build your carousel.</td></tr></table>';
            }

            let fallbackImageUrl = utils.getFieldValue('fallbackImageUrl');
            let fallbackLinkUrl = utils.getFieldValue('fallbackLinkUrl');
            let fallbackAltText = utils.getFieldValue('fallbackAltText');

            // Fallback logic remains the same: default to the first slide if fields are empty
            if (!fallbackImageUrl && slides.length > 0) {
                const firstSlide = slides[0];
                fallbackImageUrl = firstSlide.imageUrl || '';
                fallbackLinkUrl = firstSlide.linkUrl || '#';
                fallbackAltText = firstSlide.altText || '';
            }

            const slideCount = slides.length;
            const carouselSlidesWidth = slideCount * 100;
            // FIX 1: Use the raw calculation for better precision, matching AMPscript's output more closely.
            const carouselSlideWidth = 100 / slideCount; 

            const radioInputs = slides.map((s, i) => `<input type="radio" name="carousel" id="slide${i + 1}" ${i === 0 ? 'checked="checked"' : ''} style="display: none !important; mso-hide: all !important;">`).join('\n        ');
            const slideDivs = slides.map(s => `<div class="carousel-slide"><a href="${s.linkUrl || '#'}" target="_blank"><img src="${s.imageUrl || ''}" alt="${s.altText || ''}" width="620" height="350" style="display: block; width: 100%; height: 100%;"></a></div>`).join('\n            ');
            const arrowLabels = Array.from({length: slideCount}, (_, i) => `<label for="slide${i + 1}" class="arrow-left"></label>\n            <label for="slide${i + 1}" class="arrow-right"></label>`).join('\n          ');
            const dotLabels = Array.from({length: slideCount}, (_, i) => `<label for="slide${i + 1}"></label>`).join('\n            ');

            const dynamicCSS = slides.map((s, i) => {
                const slideNum = i + 1;
                const transformX = i * carouselSlideWidth;
                const prevSlide = slideNum - 1;
                const nextSlide = slideNum + 1;
                return `
      #slide${slideNum}:checked ~ .carousel-container .carousel-slides {
        transform: translateX(-${transformX}%);
        -webkit-transform: translateX(-${transformX}%);
      }
      ${slideNum > 1 ? `
      #slide${slideNum}:checked ~ .carousel-container .arrow-controls .arrow-left[for="slide${prevSlide}"] { display: block; }` : ''}
      ${slideNum < slideCount ? `
      #slide${slideNum}:checked ~ .carousel-container .arrow-controls .arrow-right[for="slide${nextSlide}"] { display: block; }` : ''}

      #slide${slideNum}:checked ~ .carousel-container .progress-dots label[for="slide${slideNum}"] {
        /* FIX 2: Corrected the active dot color to match the original. */
        background-color: #DB021D;
        border-color: rgba(0, 0, 0, 0.5);
      }
    `;
            }).join('');

            return `
<!--[if !mso]><!-->
<style type="text/css">
/* Reset styles */
body, table, td, a { -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }
table, td { mso-table-lspace: 0pt; mso-table-rspace: 0pt; }
img { -ms-interpolation-mode: bicubic; border: 0; outline: none; text-decoration: none; }

/* Hide radio buttons */
input[type="radio"] {
    display: none !important;
    mso-hide: all !important;
}

/* Mobile responsive styles */
@media screen and (max-width: 580px) {
    .content-outer {
        width: 100% !important;
        height: auto !important;
    }
}

/* Interactive carousel styles for supporting clients */
@media screen and (-webkit-min-device-pixel-ratio: 0) {
    /* Hide fallback content */
    .fallback {
        display: none !important;
    }
    
    /* Show carousel */
    .carousel-wrapper {
        display: block !important;
        max-height: none !important;
        overflow: visible !important;
    }
    
    .carousel-container {
        position: relative;
        overflow: hidden;
        width: 620px;
        height: 350px;
    }
    
    /* Carousel slides container */
    .carousel-slides {
        position: relative;
        width: ${carouselSlidesWidth}%;
        height: 100%;
        transition: transform 0.5s ease-in-out;
        -webkit-transition: -webkit-transform 0.5s ease-in-out;
    }
    
    /* Individual slides */
    .carousel-slide {
        float: left;
        width: ${carouselSlideWidth}%;
        height: 100%;
    }
    
    .carousel-slide img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
    }
    
    /* Arrow controls */
    .arrow-controls {
        position: absolute;
        top: 50%;
        width: 100%;
        margin-top: -25px;
        pointer-events: none;
    }
    
    .arrow-controls label {
        display: none;
        position: absolute;
        width: 50px;
        height: 50px;
        background-color: rgba(0, 0, 0, 0.5);
        border-radius: 50%;
        cursor: pointer;
        pointer-events: all;
        transition: background-color 0.3s;
    }
    
    .arrow-controls label:hover {
        background-color: rgba(0, 0, 0, 0.7);
    }
    
    /* Arrow icons */
    .arrow-controls label:before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 12px;
        height: 12px;
        margin: -6px 0 0 -4px;
        border-top: 3px solid #ffffff;
        border-right: 3px solid #ffffff;
    }
    
    .arrow-left {
        left: 20px;
    }
    
    .arrow-left:before {
        transform: rotate(-135deg);
        -webkit-transform: rotate(-135deg);
    }
    
    .arrow-right {
        right: 20px;
    }
    
    .arrow-right:before {
        transform: rotate(45deg);
        -webkit-transform: rotate(45deg);
        margin-left: -8px !important;
    }
    
    /* Progress dots */
    .progress-dots {
        position: absolute;
        bottom: 20px;
        left: 0;
        right: 0;
        text-align: center;
    }
    
    .progress-dots label {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: #000000;
        margin: 0 5px;
        cursor: pointer;
        transition: background-color 0.3s;
        border: 2px solid rgba(0, 0, 0, 0.3);
    }
    
    .progress-dots label:hover {
        background-color: #333333;
    }
    
    /* --- DYNAMIC CSS GENERATED BY JAVASCRIPT --- */
    ${dynamicCSS}
    /* --- END DYNAMIC CSS --- */

    @media only screen and (max-width: 620px) {
        .carousel-container {
            width: 100% !important;
            height: auto !important;
        }
        
        .carousel-container img {
            height: auto !important;
        }
    }
}

/* Hide carousel from problematic clients */
#MessageViewBody .fallback, body.MsgBody .fallback { display: block !important; }
#MessageViewBody .carousel-wrapper, body.MsgBody .carousel-wrapper { display: none !important; }

/* Outlook.com specific targeting */
[class~="x_carousel-wrapper"] { display: none !important; }
[class~="x_fallback"] { display: block !important; }

/* FIX 3: Added the missing Yahoo-specific media query. */
@media screen yahoo {
    .fallback { display: block !important; max-height: none !important; }
    .carousel-wrapper { display: none !important; max-height: 0 !important; overflow: hidden !important; }
}
</style>
<!--<![endif]-->
<!-- Separate style block for Outlook.com \\0 hack -->
<style type="text/css">
.carousel-wrapper\\0 { display: none !important; }
.fallback\\0 { display: block !important; }
</style>

<!-- Full Width Image Carousel -->
<table align="center" border="0" cellpadding="0" cellspacing="0" class="content-outer" role="presentation" style="width: 620px;">
  <tr>
    <td align="center" style="padding: 0;" valign="top">
      
      <!-- Interactive Carousel with Arrows -->
      <!--[if !mso]><!-->
      <div class="carousel-wrapper" style="display: none; max-height: 0; overflow: hidden;">
        
        <!-- Radio buttons for slide control (DYNAMIC) -->
        ${radioInputs}

        <div class="carousel-container">
          <div class="carousel-slides">
            
            <!-- Slides (DYNAMIC) -->
            ${slideDivs}

          </div>
          
          <!-- Arrow Controls (DYNAMIC) -->
          <div class="arrow-controls">
            ${arrowLabels}
          </div>
          
          <!-- Progress Dots (DYNAMIC) -->
          <div class="progress-dots">
            ${dotLabels}
          </div>

        </div>
      </div>
      <!--<![endif]-->
      
      <!-- Fallback Content (Shown by default) - Single Hero Image -->
      <div class="fallback">
        <table align="center" border="0" cellpadding="0" cellspacing="0" style="width: 100%;">
          <tr>
            <td align="center" style="padding: 0;">
              <a href="${fallbackLinkUrl}" target="_blank">
                <img src="${fallbackImageUrl}" alt="${fallbackAltText}" width="620" height="350" style="display: block; width: 100%; max-width: 620px; height: auto;">
              </a>
            </td>
          </tr>
        </table>
      </div>

    </td>

  </tr>
</table>`;
        }

        function refreshPreview() {
            if (rafId) cancelAnimationFrame(rafId);

            rafId = requestAnimationFrame(() => {
                if (state.isLoading || !state.sdk) return;
                try {
                    const html = generateTemplate();
                    state.sdk.setContent(html);

                    // Save the data for persistence and for the Preview tab
                    if (state.sdk.setData) {
                        state.sdk.setData({ ...state.blockData, content: html });
                    }
                } catch (error) {
                    utils.showError(`Preview update failed: ${error.message}`);
                }
            });
        }

        function loadData() {
            if (!state.sdk) return utils.showError('SDK not available');
            setLoadingState(true);

            state.sdk.getData((data) => {
                try {
                    // When loading, prioritize the structured 'slides' data over saved 'content'
                    state.blockData.slides = (data && data.slides && data.slides.length > 0) ? data.slides : utils.getFieldValue('slides');
                    state.blockData.slides.forEach(s => { if (!s.id) s.id = crypto.randomUUID(); });

                    state.blockData.fallbackImageUrl = data?.fallbackImageUrl || '';
                    state.blockData.fallbackLinkUrl = data?.fallbackLinkUrl || '';
                    state.blockData.fallbackAltText = data?.fallbackAltText || '';

                    renderSlidesUI();

                    elements.fallbackImageUrl.value = state.blockData.fallbackImageUrl;
                    elements.fallbackLinkUrl.value = state.blockData.fallbackLinkUrl;
                    elements.fallbackAltText.value = state.blockData.fallbackAltText;

                    refreshPreview();
                    state.retryCount = 0;
                } catch (error) {
                    utils.showError(`Failed to load data: ${error.message}`);
                    state.blockData = {}; // Reset to defaults on error
                    renderSlidesUI();
                    refreshPreview();
                } finally {
                    setLoadingState(false);
                }
            });
        }

        // Enhanced cleanup function with memory management
        function cleanup() {
            // Clean up event listeners
            state.eventListeners.forEach(({ element, event, handler }) => { 
                if (element && element.removeEventListener) element.removeEventListener(event, handler); 
            }); 
            state.eventListeners = [];

            // Cancel any pending RAF
            if (rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }

            // Clean up slide manager and all references
            SlideManager.clear();

            console.log('Image Carousel cleanup completed with enhanced memory management');
        }
        }

        function initializeWithRetry() {
            try {
                if (!window.sfdc || !window.sfdc.BlockSDK) throw new Error('BlockSDK not loaded');

                state.sdk = new window.sfdc.BlockSDK({
                    tabs: ['htmlblock']
                });
                cacheElements();
                initializeEventHandlers();
                loadData();

                // Add cleanup on page unload
                window.addEventListener('beforeunload', cleanup);

                // Add automatic cleanup on visibility change
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        console.log('Tab hidden - pausing expensive operations');
                        
                        // Pause expensive operations
                        if (rafId) {
                            cancelAnimationFrame(rafId);
                            rafId = null;
                        }
                        
                        // Clear caches to free memory (if DOMCache exists)
                        if (typeof DOMCache !== 'undefined') {
                            DOMCache.clear();
                        }
                        
                        // Perform memory cleanup with SlideManager
                        const cleanupStats = SlideManager.cleanup();
                        console.log('Visibility cleanup - slides cleaned:', cleanupStats);
                        
                        // Run garbage collection hint if available
                        if (window.gc) {
                            console.log('Running garbage collection hint');
                            window.gc();
                        }
                    } else {
                        console.log('Tab visible - resuming operations');
                        
                        // Resume operations if needed
                        if (state.isInitialized && !state.isLoading) {
                            // Recache elements if DOMCache exists
                            if (typeof cacheElements === 'function') {
                                cacheElements();
                            }
                            
                            // Refresh preview to ensure sync
                            refreshPreview();
                            
                            console.log('Operations resumed, slide stats:', SlideManager.getStats());
                        }
                    }
                });

                // Start periodic memory cleanup
                setInterval(() => {
                    const stats = SlideManager.getStats();
                    const cleaned = SlideManager.cleanup();
                    console.log('Periodic memory cleanup:', {
                        cleaned,
                        stats,
                        timestamp: new Date().toISOString()
                    });
                }, 120000); // Every 2 minutes

                state.isInitialized = true;
            } catch (error) {
                utils.showError(`Initialization failed: ${error.message}`);
                if (state.retryCount < moduleConfig.maxRetries) {
                    state.retryCount++;
                    setTimeout(() => initializeWithRetry(), 1000 * state.retryCount);
                } else {
                    utils.showError('Failed to initialize after multiple attempts. Please refresh.', true);
                }
                setLoadingState(false);
            }
        }

        document.readyState === 'loading' ? document.addEventListener('DOMContentLoaded', initializeWithRetry) : initializeWithRetry();
    </script>
</body>
</html>